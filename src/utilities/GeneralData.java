package utilities;

import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.WritableRaster;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.util.ArrayList;

import boofcv.struct.ConfigLength;
import graphics.model.data.ColorData;
import javafx.stage.Stage;

public class GeneralData 
{
	public static File sourceFolderMusic = new File(PropertyManager.getSourceFolderMusic());
	public static String destinationFolderMusic = PropertyManager.getDestinationFolderMusic();
	public static String failDestinationFolderMusic = PropertyManager.getFailDestinationFolderMusic();
	public static String resultFolderMusic = PropertyManager.getResultFolderMusic();
	public static String currentFileName = "";
	
	public static Integer numberOfFeatures = 225;
	public static String separator = ",";

	public final static Integer startIndexNotes = 0;
	public final static Integer endIndexNotes = 11;
	public final static Integer startIndexDynamics = 192;
	public final static Integer endIndexDynamics = 199;
	public final static Integer indexTempo = 214;
	public final static Integer indexClef = 215;
	public final static Integer indexTimeSignature = 216;
	public final static Integer indexAnacrusis = 217;
	
	public static Stage primaryStage;
	
	public static int screenWidth = 900;
	public static int screenHeight = 600;
	public static int innerTabHeight = 540;
	public static String currentFilePath = "";
	
	// Adjusts edge threshold for identifying pixels belonging to a line.
	public static float edgeThreshold = 25;
	// Adjust the maximum number of found lines in the image.
	public static int maxLines = 50;
	
	public static double splitFraction = 0.05;
	public static ConfigLength minimumSide = ConfigLength.relative(0.1, 0);
	
	public static int maxNumberOfSides = 100;
	public static int circleThreshold = 50;
	
	public static ArrayList<ColorData> listOfColors = new ArrayList<ColorData>();
	
	public static enum Direction	{NORTHWEST, NORTH, NORTHEAST, EAST, SOUTHEAST, SOUTH, SOUTHWEST, WEST}
	public static enum Hough		{POLAR, FOOT, FOOT_SUBIMAGE}
	public enum ScreenType 			{GRAPHICS, MUSIC, ASSOCIATION}
	
	private static String oldLine8th = "<type>8th</type>";
	private static String newLine8th = "<type>eighth</type>";
	private static String oldLine16th = "<type>16th</type>";
	private static String newLine16th = "<type>sixteenth</type>";
	
	// Method to remove the DTD line and change 16th to sixteenth in xml files generated by Musescore.
	public static void preprocessFiles()
	{
		try 
		{
			for (final File fileEntry : sourceFolderMusic.listFiles()) 
		    {
				BufferedReader reader = new BufferedReader(new FileReader(fileEntry));
				BufferedWriter writer = new BufferedWriter(new FileWriter(destinationFolderMusic + fileEntry.getName()));
			
				String currentLine;
				int counter = 0;
				
				while((currentLine = reader.readLine()) != null) 
				{
					if (counter == 1)
						// Do nothing.
						;
					else if (currentLine.contains(oldLine8th))
						writer.write(newLine8th + System.getProperty("line.separator"));
					else if (currentLine.contains(oldLine16th))
						writer.write(newLine16th + System.getProperty("line.separator"));
					else
						writer.write(currentLine + System.getProperty("line.separator"));
					
					counter++;
				}
				
				reader.close();
				writer.close();
		    }		
		} 
		catch (IOException e) { e.printStackTrace(); }	
	}
	 
    public static void preprocessFailFiles(File folder)
    {
        try
        {
            for (final File fileEntry : folder.listFiles()) 
            {
                BufferedReader reader = new BufferedReader(new FileReader(fileEntry));
                BufferedWriter writer = new BufferedWriter(new FileWriter(failDestinationFolderMusic + fileEntry.getName()));
             
                String currentLine;
                int counter = 0;
                 
                while((currentLine = reader.readLine()) != null) 
                {
                    if (counter == 1)
                        // Do nothing.
                        ;
                    else if (currentLine.contains(oldLine8th))
                        writer.write(newLine8th + System.getProperty("line.separator"));
                    else if (currentLine.contains(oldLine16th))
                        writer.write(newLine16th + System.getProperty("line.separator"));
                    else
                        writer.write(currentLine + System.getProperty("line.separator"));
                     
                    counter++;
                }
                 
                reader.close();
                writer.close();
            }       
        } 
        catch (IOException e) { e.printStackTrace(); }  
    }
    
    public static int mod(int a, int n) 
    {
    	int ret = a % n;
	    if (ret < 0)
	        ret += n;
	    return ret;
    }
	
	public static void resetColors()
	{
		for (ColorData currentColor : listOfColors)
			currentColor.setPercentage(0.0);
	}
	
	public static float[] convertHexToHSV(int hex)
	{
	    float r = (hex & 0xFF0000) >> 16;
	    float g = (hex & 0xFF00) >> 8;
	    float b = (hex & 0xFF);
	     
	    float rTemp = r / 255;
	    float gTemp = g / 255;
	    float bTemp = b / 255;
	    
	    float cMax = Math.max(rTemp, Math.max(gTemp, bTemp));
	    float cMin = Math.min(rTemp, Math.min(gTemp, bTemp));
	    float difference = cMax - cMin;
	    
	    float hue = 0.0f;
	    float saturation = 0.0f;
	    float value = 0.0f;
	    
	    if (difference == 0.0f)
	    	hue = 0.0f;
	    else if (cMax == rTemp)
	    	hue = (float) (1.0471975512f * (((gTemp - bTemp) / difference) % 6));
		else if (cMax == gTemp)
	    	hue = (float) (1.0471975512f * (((bTemp - rTemp) / difference) + 2.0));
		else if (cMax == bTemp)
	    	hue = (float) (1.0471975512f * (((rTemp - gTemp) / difference) + 4.0));
	    
	    if (cMax == 0.0f)
	    	saturation = 0.0f;
	    else
	    	saturation = difference / cMax;
	    
	    value = cMax;
	   
	    float[] tempColor = {hue, saturation, value};
	    return tempColor;
	}
	
	public static int[] convertHexToRGB(int hex)
	{
	    int r = (hex & 0xFF0000) >> 16;
	    int g = (hex & 0xFF00) >> 8;
	    int b = (hex & 0xFF);
	    
	    int[] tempColor = {r, g, b};
	    
	    return tempColor;
	}
	
	public static BufferedImage deepCopy(BufferedImage source)
	{
		ColorModel cm = source.getColorModel();
		boolean isAlphaPremultiplied = cm.isAlphaPremultiplied();
		WritableRaster raster = source.copyData(null);
		
		return new BufferedImage(cm, raster, isAlphaPremultiplied, null);
	}
	
	public static String decimalFormat(double value)
	{
		DecimalFormat doubleFormat = new DecimalFormat("#####.#####");
		doubleFormat.setRoundingMode(RoundingMode.HALF_UP);
		
		return String.format("%s", doubleFormat.format(value));
	}
}
